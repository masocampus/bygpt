# 어떤 것이 좋은 알고리즘인가? 

# Egg Drop Competition
# 설명 : 내용물이 부서지지 않도록 하는 완충 장치를 만든다
# 그리고, 완충장치의 성능을 알기 위해서 달걀을 하나 넣고
# 100층 빌딩에서 낙하실험을 하여 달걀이 몇 층까지 깨지지 않고 견디는지 테스트를 한다. 
# 몇 층까지 깨지지 않을까? 

# 알고리즘1 - 가장 간단한 방법
# 스텝 - 한 층씩 올라가서 떨어뜨려 보기
# -> 100층에서 깨진다면 100번 시도가 필요
# 방식 = 순차구조 + 선택구조
# 방식 = 순차구조 + 선택구조 + 반복구조

# 알고리즘2 - 보다 효율적인 방법
# 스텝 - 50층에서 시도
# 설명 - 중간 층에서 시작해서 절반씩 범위를 줄여가서 실험하기
# 더이상 움직일 층이 없을때까지 시도

# 달걀이 계속 깨진다고 가정한다면 시도 횟수는? 
# 50층 -> 25층 -> 13층 -> 6층 -> 3층 -> 2층 -> 1층

# 알고리즘 이름 : Binary Search Algorithm
# 이 상황의 경우 최소 1회, 초대 7회의 낙하실험을 하면 몇 층에서 달걀이 깨지는 지 알 수 있음

# 목적이 개발자 구성원들이 이해하기 쉽고, 
# 새로운 구성원이 조인해서도 커뮤니케이션 하기 쉽게 코딩을 한다고 한다면 
# 알고리즘1을 사용하는 것이 효율적일 수도 있음

# 그렇다면, 알고리즘2는 어떤 경우에 사용해야 하는가? 
# 프로그램 개발에서 '성능'이 매우 중요한 요소인 경우 알고리즘2를 사용해야 함
# 게임 서버 개발 - 현재 동시접속자 1,000명을 감당할 수 있음
# 서버의 핵심 알고리즘 개선 - 성능을 10% 개선할 수 있음
# 그 경우에는 동일 스펙 서버로 1,100명 대상 서비스를 할 수 있게 되는 것임

# 한 개의 거대 서비스를 개발/운영하는 상황이라고 한다면 
# 90%의 상황은 서로 이해하기 쉬운 코딩을 하는 것이 더 효율적일 수 있으며
# 매우 적은(이 경우 10% 정도) 경우에 성능이 중요한 알고리즘을 구현하는 것이 더 효율적일 수 있음

# 알고리즘3 - 직관
# 이 장치의 경우 적어도 4층까지는 버틸 것 같음
# 실험 범위를 6 ~ 7 층 정도에서 첫 시도를 하는 방식으로 
# 실험 횟수를 줄일 수 있음
# 직관(경험) 기반 의사결정 방식


# 알고리즘4 - 데이터 기반
# 과거 데이터를 참고하니, 현재 도구보다 더 열악한 도구의 경우 
# 30층까지 깨지지 않았던 기록이 존재함 
# 첫 번째 실험 고려 대상 층수를 31층 이상에서 고려하는 방식으로 
# 실험 시도 횟수를 줄여나갈 수 있음
# 데이터에 근거한 의사결정 방식


